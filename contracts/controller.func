;; The validator has his own wallet on which he holds his own coins for operating.
;; From this wallet (s)he sends commands to this validator-controller (mostly `new_stake`, `update_validator_set` and `recover_stake`).
;; validator-controller contract must be in masterchain.
;; The validator in most cases have two validator-controllers (for even and odd validation rounds).


{-
 TODO:
   1) move config_param(1) to constants
   2) elector_address() can be optimized
-}

#include "stdlib.func";
#include "op-codes.func";
#include "messages.func";
#include "errors.func";
#include "asserts.func";
#include "utils.func";
#include "network_config_utils.func";
#include "sudoer_requests.func";
#include "governor_requests.func";
#include "halter_requests.func";


const int ONE_TON = 1000000000;
const int ELECTOR_OPERATION_VALUE = 103 * ONE_TON / 100 ;
const int MIN_TONS_FOR_STORAGE = 2 * ONE_TON; ;; 10 TON
const int DEPOSIT_FEE = ONE_TON / 4; ;; 0.25 TON
const int WITHDRAWAL_FEE = ONE_TON / 4; ;; 0.25 TON
const int MIN_STAKE_TO_SEND = 50000 * ONE_TON; ;; 300 000 TON
const int MASTERCHAIN = -1;

;; Time in seconds for validator to make mandatory actions, such as
;; recover stake or update hash
const int GRACE_PERIOD = 600;
;; Fines for validator for overdue actions
const int HASH_UPDATE_FINE = 10 * ONE_TON;
const int STAKE_RECOVER_FINE = 10 * ONE_TON;

;; Whole storage is put to global variables

global int state;
global int approved;

global int stake_amount_sent;
global int stake_at;

global int saved_validator_set_hash;
global int validator_set_changes_count;
global int validator_set_change_time;
global int stake_held_for;

global int borrowed_amount;
global int borrowing_time;

global slice sudoer;
global int sudoer_set_at;

global slice static_data;
global int controller_id;
global slice validator;
global slice pool;
global slice governor;
global slice halter;
global slice approver;



const int state::REST = 0;
const int state::SENT_BORROWING_REQUEST = 1;
const int state::SENT_STAKE_REQUEST = 2;
const int state::FUNDS_STAKEN = 3;
const int state::HALTED = 0xff;

() save_data() impure;
() load_data() impure;

slice elector_address();
int is_elector_address(slice address);
;;int max_recommended_punishment_for_validator_misbehaviour(int stake);
;;(int, int, int) get_validator_config();
;;int get_stake_held_for();
;;int get_elections_start_before();
;;(int, int, cell) get_current_validator_set();
int check_new_stake_msg(slice cs);

() recv_internal(int balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);

    slice sender_address = cs~load_msg_addr();
    load_data();
    if (flags & 1) { ;; bounced messages
        if (in_msg_body.slice_bits() >= 64) {
            in_msg_body~skip_bits(32); ;; skip 0xFFFFFFFF bounced prefix
            int op = in_msg_body~load_op();
            if ((op == elector::new_stake) & (is_elector_address(sender_address))) {
                ;; `new_stake` from nominator-pool should always be handled without throws by elector
                ;; because nominator-pool do `check_new_stake_msg` and `msg_value` checks before sending `new_stake`.
                ;; If the stake is not accepted elector will send `new_stake_error` response message.
                ;; Nevertheless we do process theoretically possible bounced `new_stake`.

                if (state == state::SENT_STAKE_REQUEST) {
                    state = state::REST;
                }
            } elseif (equal_slice_bits(sender_address, pool)) {
              if(op == pool::loan_repayment) {
                borrowed_amount += msg_value;
                borrowing_time = now();
              } elseif (op == pool::request_loan) {
                if (state == state::SENT_BORROWING_REQUEST) {
                  state = state::REST;
                }
              }
            }
        }

        save_data();
        return (); ;; ignore other bounces messages
    }

    (int op, int query_id) = in_msg_body~load_body_header();

    if (is_elector_address(sender_address)) { ;; response from elector

            accept_message();

            if (op == elector::recover_stake_ok) {
                state = state::REST;
                if(balance >= MIN_TONS_FOR_STORAGE + borrowed_amount) {
                  send_msg(pool,
                           borrowed_amount, ;; TODO add fee???
                           begin_cell().store_body_header(pool::loan_repayment, query_id).end_cell(),
                           msgflag::BOUNCEABLE,
                           sendmode::PAY_FEES_SEPARETELY); ;; remaining inbound message amount, fee deducted from
                  borrowed_amount = 0;
                  borrowing_time = 0;
                } else {
                  state = state::HALTED;
                }
            }

            if (state == state::SENT_STAKE_REQUEST) {
                if (op == elector::new_stake_error) { ;; error when new_stake; stake returned
                    state = state::REST;
                }

                if (op == elector::new_stake_ok) {
                    state = state::FUNDS_STAKEN;
                }
            }

            ;; else just accept coins from elector

    } else {

            if (op == controller::top_up) {
                ;; just accept coins
            } elseif (op == controller::credit) {
                assert_sender!(sender_address, pool);
                ;; borrowed_amount includes interest
                ifnot(borrowing_time) {
                  borrowing_time = now();
                }
                borrowed_amount += in_msg_body~load_coins();
                in_msg_body.end_parse();
                state = state::REST;
            } elseif (op == controller::approve) {
                assert_sender!(sender_address, approver);
                approved = true;
            }  elseif (op == controller::disapprove) {
                assert_sender!(sender_address, approver);
                approved = false;
            } elseif (op == sudo::send_message) {
                process_sudo_request(sender_address, in_msg_body);
            } elseif (op == governor::set_sudoer) {
                process_set_sudo_request(sender_address, in_msg_body);
            }  elseif (op == governor::unhalt) {
                process_unhalt_request(sender_address, in_msg_body);
            } elseif (op == halter::halt) {
                process_halt_request(sender_address, in_msg_body);
            } elseif (op == controller::recover_stake) { ;; send recover_stake to elector
                assert_state!(state::FUNDS_STAKEN);
                in_msg_body.end_parse();
                ;; We need to take all credits from the elector at once,
                ;; because if we do not take all at once, then it will be processed as a fine by pool.
                ;; In the elector, credits (`credit_to`) are accrued in three places:
                ;; 1) return of surplus stake in elections (`try_elect`)
                ;; 2) reward for complaint when punish (`punish`) - before unfreezing
                ;; 3) unfreeze round (`unfreeze_without_bonuses`/`unfreeze_with_bonuses`)
                ;; We need to be guaranteed to wait for unfreezing round and only then send `recover_stake`.
                ;; So we are waiting for the change of 3 validator sets.

                ;; ADDITIONAL NOTE:
                ;; In a special case (if the network was down), the config theoretically can refuse the elector to save a new round after election - https://github.com/ton-blockchain/ton/blob/b38d227a469666d83ac535ad2eea80cb49d911b8/crypto/smartcont/config-code.fc#L494
                ;; and the elector will start a new election - https://github.com/ton-blockchain/ton/blob/b38d227a469666d83ac535ad2eea80cb49d911b8/crypto/smartcont/elector-code.fc#L364
                ;; in this case, our pool will have to skip the round, but it will be able to recover stake later

                throw_unless(error::too_early_stake_recover_attempt_count, validator_set_changes_count >= 2);
                int time_since_unfreeze = now() - validator_set_change_time - stake_held_for;
                throw_unless(error::too_early_stake_recover_attempt_time, (validator_set_changes_count > 2) | (time_since_unfreeze > 60));
                ;; https://github.com/ton-blockchain/ton/blob/b38d227a469666d83ac535ad2eea80cb49d911b8/crypto/smartcont/elector-code.fc#L887
                throw_unless(error::too_low_recover_stake_value, msg_value >= ELECTOR_OPERATION_VALUE);

                cell payload = begin_cell().store_body_header(elector::recover_stake, query_id).end_cell();
                send_msg(elector_address(),
                         0, ;; amount
                         payload,
                         msgflag::BOUNCEABLE,
                         sendmode::CARRY_ALL_REMAINING_MESSAGE_VALUE); ;; remaining inbound message amount, fee deducted from amount, revert on errors
                if( (time_since_unfreeze < GRACE_PERIOD) | (borrowed_amount == 0) ) {
                  assert_sender!(sender_address, validator);
                } else {
                  if(balance - msg_value - STAKE_RECOVER_FINE >= MIN_TONS_FOR_STORAGE) {
                    ifnot( equal_slice_bits(sender_address, validator)) {
                      send_msg(sender_address, STAKE_RECOVER_FINE, null(), msgflag::NON_BOUNCEABLE, sendmode::IGNORE_ERRORS);
                    }
                  }
                }
            } elseif (op == controller::update_validator_hash) {
                assert_state!(state::FUNDS_STAKEN);
                in_msg_body.end_parse();
                throw_unless(error::too_much_validator_set_counts, validator_set_changes_count < 3);
                (int utime_since, int utime_until, cell vset) = get_current_validator_set();
                int current_hash = cell_hash(vset);
                if (saved_validator_set_hash != current_hash) {
                    saved_validator_set_hash = current_hash;
                    validator_set_changes_count += 1;
                    validator_set_change_time = now();
                }
                int overdue = now() - utime_since;
                if( (overdue < GRACE_PERIOD) | (borrowed_amount == 0) ) {
                  assert_sender!(sender_address, validator);
                  send_excesses(sender_address);
                } else {
                  if(balance - HASH_UPDATE_FINE >= MIN_TONS_FOR_STORAGE) {
                    ifnot( equal_slice_bits(sender_address, validator)) {
                      send_msg(sender_address, HASH_UPDATE_FINE, null(), msgflag::NON_BOUNCEABLE, sendmode::IGNORE_ERRORS);
                    }
                  }
                }
            } elseif (op == controller::withdraw_validator) { ;; withdraw validator (after recover_stake and before new_stake)
                assert_state!(state::REST);
                throw_if(error::withdrawal_while_credited, borrowed_amount);
                assert_sender!(sender_address, validator);
                int request_amount = in_msg_body~load_coins();
                in_msg_body.end_parse();
                throw_unless(error::incorrect_withdrawal_amount, request_amount > 0);

                raw_reserve(MIN_TONS_FOR_STORAGE, 2);
                send_msg(validator,
                         request_amount,
                         null(), ;; payload
                         msgflag::NON_BOUNCEABLE,
                         sendmode::IGNORE_ERRORS | sendmode::CARRY_ALL_REMAINING_MESSAGE_VALUE);

            } elseif (op == controller::new_stake) {
                assert_state!(state::REST);
                assert_sender!(sender_address, validator);

                throw_unless(error::incorrect_new_stake::query_id, query_id); ;; query_id must be greater then 0 to receive confirmation message from elector

                throw_unless(error::incorrect_new_stake::request_value,
                             msg_value >= ELECTOR_OPERATION_VALUE); ;; must be greater then new_stake sending to elector fee

                int value = in_msg_body~load_coins();

                slice msg = in_msg_body;

                stake_at = check_new_stake_msg(in_msg_body);

                stake_amount_sent = value - ELECTOR_OPERATION_VALUE;

                throw_unless(error::incorrect_new_stake::value_lt_minimum, value >= MIN_STAKE_TO_SEND);

                int overdue_fine = (HASH_UPDATE_FINE * 3) - STAKE_RECOVER_FINE;

                throw_unless(error::incorrect_new_stake::value_too_high, balance - value >=  MIN_TONS_FOR_STORAGE + overdue_fine);
                (_, stake_held_for, int elections_end_before) = get_validator_config();
                (int utime_since, int utime_until, cell vset) = get_current_validator_set();
                if (borrowed_amount) {
                  ;; it is allowed to use credit funds only in the same round when they were obtained
                  throw_unless(error::incorrect_new_stake::wrongly_used_credit,
                              (borrowing_time > utime_since) & (now() < utime_until - elections_end_before));
                }

                int validator_own_funds = balance - borrowed_amount;

                throw_unless(error::incorrect_new_stake::solvency_not_guaranteed,
                             validator_own_funds >= max_recommended_punishment_for_validator_misbehaviour(stake_amount_sent) + (overdue_fine + MIN_TONS_FOR_STORAGE));

                state = state::SENT_STAKE_REQUEST;



                saved_validator_set_hash = cell_hash(vset); ;; current validator set, we will be in next validator set
                validator_set_changes_count = 0;
                validator_set_change_time = utime_since;

                send_msg(elector_address(),
                         value,
                         begin_cell().store_body_header(elector::new_stake, query_id).store_slice(msg).end_cell(),
                         msgflag::BOUNCEABLE,
                         sendmode::PAY_FEES_SEPARETELY); ;; pay fee separately, revert on errors

            } elseif (op == controller::send_request_loan) {
              assert_state!(state::REST);
              assert_sender!(sender_address, validator);
              slice request = in_msg_body;
              int min_loan = in_msg_body~load_coins();
              int max_loan = in_msg_body~load_coins();
              int max_interest = in_msg_body~load_uint(16);
              in_msg_body.end_parse();

              throw_unless(error::controller_not_approved, approved);

              ;; For simplicity forbid multiple borrowing
              ;; TODO
              throw_if(error::multiple_loans_are_prohibited, borrowed_amount);

              (int elections_start_before, _, int elections_end_before) = get_validator_config();
              (int utime_since, int utime_until, cell vset) = get_current_validator_set();
              throw_unless(error::too_early_loan_request, now() > utime_until - elections_start_before); ;; elections should be started
              throw_unless(error::too_late_loan_request, now() < utime_until - elections_end_before);   ;; elections should be not closed yet


              ;; lets check whether we can afford it
              int elector_fine = max_recommended_punishment_for_validator_misbehaviour(max_loan + balance);
              int overdue_fine = (HASH_UPDATE_FINE * 3) - STAKE_RECOVER_FINE;
              int interest_payment = muldiv(max_loan, max_interest, 65535);
              int validator_amount = balance - borrowed_amount;

              throw_unless(error::too_high_loan_request_amount,
                           validator_amount >= MIN_TONS_FOR_STORAGE
                                                 + overdue_fine
                                                 + elector_fine
                                                 + interest_payment);

              cell payload = begin_cell()
                               .store_body_header(pool::request_loan, query_id)
                               .store_slice(request)
                               .store_slice(static_data)
                             .end_cell();
              send_msg(pool,
                       0,
                       payload,
                       msgflag::BOUNCEABLE,
                       sendmode::CARRY_ALL_REMAINING_MESSAGE_VALUE);

              state = state::SENT_BORROWING_REQUEST;
            } elseif (op == controller::return_unused_loan) {
                assert_state!(state::REST);
                throw_unless(error::no_credit, borrowed_amount);
                (int utime_since, int utime_until, cell vset) = get_current_validator_set();
                throw_unless(error::too_early_loan_return, utime_since > borrowing_time); ;; load was requested in previous round
                int overdue = now() - utime_since;
                if(balance >= MIN_TONS_FOR_STORAGE + borrowed_amount) {
                  send_msg(pool,
                           borrowed_amount, ;; TODO add fee???
                           begin_cell().store_body_header(pool::loan_repayment, query_id).end_cell(),
                           msgflag::BOUNCEABLE,
                           sendmode::PAY_FEES_SEPARETELY); ;; remaining inbound message amount, fee deducted from
                  borrowed_amount = 0;
                  borrowing_time = 0;
                  if(overdue < GRACE_PERIOD) {
                    assert_sender!(sender_address, validator);
                    send_excesses(sender_address);
                  } else {
                    if(balance >=  MIN_TONS_FOR_STORAGE + borrowed_amount + STAKE_RECOVER_FINE) {
                      ifnot( equal_slice_bits(sender_address, validator)) {
                        send_msg(sender_address, STAKE_RECOVER_FINE, null(), msgflag::NON_BOUNCEABLE, sendmode::IGNORE_ERRORS);
                      }
                    }
                  }
                } else {
                  state = state::HALTED;
                }
            } else {
              throw(error::unknown_op);
            }
    }

    save_data( );
}

() save_data() impure inline_ref {
    set_data(begin_cell()
        .store_uint(state, 8)
        .store_int(approved, 1)
        .store_coins(stake_amount_sent)
        .store_timestamp(stake_at)
        .store_uint(saved_validator_set_hash, 256)
        .store_uint(validator_set_changes_count, 8)
        .store_timestamp(validator_set_change_time)
        .store_timestamp(stake_held_for)
        .store_coins(borrowed_amount)
        .store_timestamp(borrowing_time)
        .store_slice(sudoer)
        .store_timestamp(sudoer_set_at)
        .store_slice(static_data)
        .end_cell());
}

() load_data() impure inline_ref {

    slice ds = get_data().begin_parse();
    state = ds~load_uint(8);
    approved = ds~load_int(1);

    stake_amount_sent = ds~load_coins();
    stake_at = ds~load_timestamp();

    saved_validator_set_hash = ds~load_uint(256);
    validator_set_changes_count = ds~load_uint(8);
    validator_set_change_time = ds~load_timestamp();
    stake_held_for = ds~load_timestamp();

    borrowed_amount = ds~load_coins();
    borrowing_time = ds~load_timestamp();

    sudoer = ds~load_msg_addr();
    sudoer_set_at = ds~load_timestamp();

    static_data = ds;

    ds = ds~load_ref().begin_parse();

    controller_id = ds~load_uint(32);
    validator = ds~load_msg_addr();
    pool = ds~load_msg_addr();
    governor = ds~load_msg_addr();

    ds = ds~load_ref().begin_parse();

    approver = ds~load_msg_addr();
    halter = ds~load_msg_addr();
}


slice make_address(int wc, int addr) inline_ref {
    return begin_cell()
           .store_uint(4, 3).store_int(wc, 8).store_uint(addr, ADDR_SIZE).end_cell().begin_parse();
}

slice elector_address() inline_ref {
    int elector = config_param(1).begin_parse().preload_uint(ADDR_SIZE);
    return make_address(MASTERCHAIN, elector);
}

;; https://github.com/ton-blockchain/ton/blob/ae5c0720143e231c32c3d2034cfe4e533a16d969/crypto/block/block.tlb#L584
int is_elector_address(slice address) inline_ref {
  return equal_slice_bits(address, elector_address());
}


;; check the validity of the new_stake message
;; https://github.com/ton-blockchain/ton/blob/b38d227a469666d83ac535ad2eea80cb49d911b8/crypto/smartcont/elector-code.fc#L208
int check_new_stake_msg(slice cs) impure inline_ref {
    var validator_pubkey = cs~load_uint(256);
    var stake_at = cs~load_uint(32);
    var max_factor = cs~load_uint(32);
    var adnl_addr = cs~load_uint(256);
    var signature = cs~load_ref().begin_parse().preload_bits(512);
    cs.end_parse();
    return stake_at; ;; supposed start of next validation round (utime_since)
}

;; Get methods

_ get_validator_controller_data() method_id {
    load_data();
    return (
      state, approved,
      
      stake_amount_sent, stake_at,
      
      saved_validator_set_hash,
      validator_set_changes_count,
      validator_set_change_time,
      stake_held_for,
      
      borrowed_amount, borrowing_time,
      validator, pool, sudoer
      );
}

int get_max_punishment(int stake) method_id {
    return max_recommended_punishment_for_validator_misbehaviour(stake);
}

(int, int) required_balance_for_loan(int credit, int interest) method_id {
    load_data();
    int balance = pair_first(get_balance());
    int elector_fine = max_recommended_punishment_for_validator_misbehaviour(credit + balance);
    int overdue_fine = (HASH_UPDATE_FINE * 3) - STAKE_RECOVER_FINE;
    int interest_payment = muldiv(credit, interest, 65535);
    int validator_amount = balance - borrowed_amount;
    return (MIN_TONS_FOR_STORAGE + overdue_fine + elector_fine + interest_payment,
            validator_amount);
}
