;;[lenders_dict, round_id, active_lenders, lended, expected, returned, profit]
(slice, ([cell, int, int, int, int, int, int])) ~load_round_data(slice s) {
    slice ds = s~load_ref().begin_parse();
    var data = [ds~load_dict(),             ;; lenders
                ds~load_uint(32),           ;; round_id
                ds~load_uint(32),           ;; active_lenders
                ds~load_coins(),            ;; lended
                ds~load_coins(),            ;; expected
                ds~load_coins(),            ;; returned
                ds~load_signed_coins()];    ;; profit
   return (s, (data));
}

builder store_round_data(builder b, [cell, int, int, int, int, int, int] round_data) {
  var [lenders_dict, round_id, active_lenders, lended, expected, returned, profit] = round_data;
  cell serialized = begin_cell()
                     .store_dict(lenders_dict)
                     .store_uint(round_id, 32)
                     .store_uint(active_lenders, 32)
                     .store_coins(lended)
                     .store_coins(expected)
                     .store_coins(returned)
                     .store_signed_coins(profit)
                     .end_cell();
  return b.store_ref(serialized);
}


(slice, ()) ~load_minters_data(slice s) impure inline {
    slice ds = s~load_ref().begin_parse();
    jetton_minter = ds~load_msg_addr();
    supply = ds~load_coins();

    deposit_payout = null();
    requested_for_deposit = 0;
    ;; (Maybe (Either X, ^X))
    if(ds~load_int(1)) {
      if(ds~load_int(1)) {
        slice ajm_s = ds~load_ref().begin_parse();
        deposit_payout = ajm_s~load_msg_addr();
        requested_for_deposit = ajm_s~load_coins();
      } else {
        deposit_payout = ds~load_msg_addr();
        requested_for_deposit = ds~load_coins();
      }
    }

    withdrawal_payout = null();
    requested_for_withdrawal = 0;
    ;;(Maybe (Either X, ^X)) 
    if(ds~load_int(1)) {
      if(ds~load_int(1)) {
          slice atm_s = ds~load_ref().begin_parse();
          withdrawal_payout = atm_s~load_msg_addr();
          requested_for_withdrawal = atm_s~load_coins();
      } else {
          withdrawal_payout = ds~load_msg_addr();
          requested_for_withdrawal = ds~load_coins();
      }
    }
    return (s, ());
}

builder save_minters_data(builder pb) {
    builder b = begin_cell()
                 .store_slice(jetton_minter)
                 .store_coins(supply);
    if(deposit_payout.null?()) {
      b = b.store_int(false, 1);
    } else {
      b = b.store_int(true, 1) ;; Maybe
           .store_int(false, 1) ;;Either X
           .store_slice(deposit_payout)
           .store_coins(requested_for_deposit);
    }
    if(withdrawal_payout.null?()) {
      b = b.store_int(false, 1);
    } else {
      b = b.store_int(true, 1);
      if(b.builder_bits() > 1023 - 267 - 124) {
        b = b.store_int(true, 1) ;;Either ^X
              .store_ref(
              begin_cell()
                .store_slice(withdrawal_payout)
                .store_coins(requested_for_withdrawal)
              .end_cell()
            );
      } else {
        b = b.store_int(false, 1) ;;Either X
             .store_slice(withdrawal_payout)
             .store_coins(requested_for_withdrawal);
      }
    }
    return pb.store_ref(b.end_cell());
}



(slice, ()) ~load_roles(slice s) impure inline {
    slice ds = s~load_ref().begin_parse();
    sudoer = ds~load_msg_addr();
    sudoer_set_at = ds~load_uint(48);
    governor = ds~load_msg_addr();
    interest_manager = ds~load_msg_addr();
    ds = ds~load_ref().begin_parse();
    halter = ds~load_msg_addr();
    consigliere = ds~load_msg_addr();
    approver = ds~load_msg_addr();
    return (s, ());
}

builder save_roles(builder pb) {
    cell roles = begin_cell()
                 .store_slice(sudoer)
                 .store_uint(sudoer_set_at, 48)
                 .store_slice(governor)
                 .store_slice(interest_manager)
                 .store_ref(
                   begin_cell()
                   .store_slice(halter)
                   .store_slice(consigliere)
                   .store_slice(approver)
                   .end_cell()
                  )
                 .end_cell();
   return pb.store_ref(roles);
}

(slice, ()) ~load_codes(slice s) impure inline {
    slice ds = s~load_ref().begin_parse();
    controller_code = ds~load_ref();
    payout_wallet_code = ds~load_ref();
    pool_jetton_wallet_code = ds~load_ref();
    ds = ds~load_ref().begin_parse();
    payout_minter_code = ds~load_ref();
    vote_keeper_code = ds~load_ref();
    return (s, ());
}

builder save_codes(builder pb) {
    cell codes = begin_cell()
                 .store_ref(controller_code)
                 .store_ref(payout_wallet_code)
                 .store_ref(pool_jetton_wallet_code)
                 .store_ref(
                     begin_cell()
                     .store_ref(payout_minter_code)
                     .store_ref(vote_keeper_code)
                     .end_cell()
                 )
                 .end_cell();
   return pb.store_ref(codes);
}


() load_data() impure inline_ref {

    ;; this check should be removed in production
    ;; it ensures that load_data is not loaded twice
    throw_unless(2222, state.null?());

    slice ds = get_data().begin_parse();
    state = ds~load_uint(8);
    total_balance = ds~load_coins();
    interest_rate = ds~load_uint(16);
    optimistic_deposit_withdrawals = ds~load_int(1);
    deposits_open? = ds~load_int(1);
    saved_validator_set_hash = ds~load_uint(256);
    slice round_data = ds~load_ref().begin_parse();
        current_round_lenders = round_data~load_round_data();
        prev_round_lenders = round_data~load_round_data();
    min_loan_per_validator = ds~load_coins();
    max_loan_per_validator = ds~load_coins();
    governance_fee = ds~load_uint(8);
    ds~load_minters_data();
    ds~load_roles();
    ds~load_codes();
}

() save_data() impure inline_ref {
    set_data(begin_cell()
        .store_uint(state, 8)
        .store_coins(total_balance)
        .store_uint(interest_rate, 16)
        .store_int(optimistic_deposit_withdrawals, 1)
        .store_int(deposits_open?, 1)
        .store_uint(saved_validator_set_hash, 256)
        .store_ref(
          begin_cell()
          .store_round_data(current_round_lenders)
          .store_round_data(prev_round_lenders)
          .end_cell()
        )
        .store_coins(min_loan_per_validator)
        .store_coins(max_loan_per_validator)
        .store_uint(governance_fee, 8)
        .save_minters_data()
        .save_roles()
        .save_codes()
        .end_cell()
    );
}
