#include "stdlib.func";
#include "op-codes.func";
#include "errors.func";
#include "messages.func";
#include "asserts.func";
#include "utils.func";
#include "sudoer_requests.func";
#include "address_calculations.func";
#include "governor_requests.func";
#include "halter_requests.func";
#include "network_config_utils.func";
#include "jetton_dao/contracts/jetton-utils.func";

;; Whole storage is put to global variables

global int state;
global int halted?;
global int total_balance;
global int interest_rate; ;; times 2**16
global int optimistic_deposit_withdrawals;
global int deposits_open?;
global int saved_validator_set_hash;

;; [borrowers_dict, round_id, active_borrowers, borrowed, expected, returned, profit]
global [cell, int, int, int, int, int, int] current_round_borrowers;
global [cell, int, int, int, int, int, int] prev_round_borrowers;

global int min_loan_per_validator;
global int max_loan_per_validator;
global int governance_fee; ;; times 2**16

;; Basic jetton that represents share of the pool
global slice jetton_minter;
global int supply;

global slice deposit_payout;
global int requested_for_deposit;    ;; in TONs
global slice withdrawal_payout;
global int requested_for_withdrawal; ;; in jettons

;; ROLES
global slice sudoer;            ;; hav right to send any message on behalf of any contract
global int sudoer_set_at;
global slice governor;          ;; set roles, unhalt and get reward
global slice interest_manager;  ;; get round stats and update interest
global slice halter;            ;; halts operation
global slice approver;          ;; approves controllers to ask for credit

;; CHILD CONTRACT CODES
global cell controller_code;
global cell pool_jetton_wallet_code;
global cell payout_minter_code;


;; temporal variables (not saved to storage)
global int sent_during_rotation;
global int current_round_closed?; ;; hash of validator set changed since round start

const int state::NORMAL = 0;
const int state::REPAYMENT_ONLY = 1;

const int ONE_TON = 1000000000;
const int disbalance_tolerance = 30; ;; x/256
const int MIN_TONS_FOR_STORAGE = 10 * ONE_TON; ;; 10 TON
const int CONTROLLER_WORKCHAIN = -1; ;; masterchain
const int MAX_LOAN_DICT_DEPTH = 12;
const int SERVICE_NOTIFICATION_AMOUNT = ONE_TON / 100;
const int FINALIZE_ROUND_FEE = ONE_TON;
const int DEPOSIT_FEE = ONE_TON; ;;TODO reconsider
const int WITHDRAWAL_FEE = ONE_TON / 2;
const int TRANSFER_NOTIFICATION_AMOUNT = ONE_TON / 10;
const int PAYOUT_PROCESS_FEE = ONE_TON / 7; ;; Due to consigliere wallet_fee is >= 0.1
const int POOL_JETTON_WALLET_FEE = 22900000; ;; 0.0229
const int MAX_POOL_GAS_ON_USER_ACTION = ONE_TON / 3;
const int POOL_JETTON_MINT_FEE = 27500000; ;; 0.0275
const int PAYOUT_ITEM_MINT_FEE = ONE_TON / 6;
const int MINT_PAYOUT_FEE = ONE_TON / 20;
const int MINTER_DEPLOY_FEE = ONE_TON / 5;
const int JETTONS_WORKCHAIN = 0;


#include "pool_storage.func";

() update_round() impure;

() log_loan (slice, int)  impure;
() log_repayment (slice, int, int) impure;
() log_round_completion (int, int, int, int) impure;
() log_round_rotation (int) impure;

([cell, int, int, int, int, int, int], ()) finalize_lending_round([cell, int, int, int, int, int, int] borrowers_data)  impure; ;; called from close_loan
() finalize_deposit_withdrawal_round (int round_id)  impure; ;; called from finalize_lending_round


([cell, int, int, int, int, int, int], (int)) ~add_loan([cell, int, int, int, int, int, int] borrowers_data, slice borrower, int loan_body, int interest);
([cell, int, int, int, int, int, int], (int, int)) ~close_loan([cell, int, int, int, int, int, int] borrowers_data, slice borrower, int amount);

slice _get_controller_address (int controller_id, slice validator) method_id;
(slice, cell) build_controller_address(int controller_id, slice validator);

() request_to_mint_pool_jettons(slice destination, int amount, int query_id, builder payload, int for_user?) impure;
() request_to_mint_deposit(slice destination, int amount, int query_id) impure;
() request_to_mint_withdrawal(slice destination, int amount, int query_id) impure;

() initiate_distribution_of_tons (int round_id) impure;
() initiate_distribution_of_pool_jettons (int round_id) impure;

(int, int) _get_projected_conversion_ratio () inline;

;; special muldiv which is friendly for b == c == 0
int muldiv_extra(int a, int b, int c) inline {
    if(b == c) {
      return a;
    }
    return muldiv(a, b, c);
}

int current_round_index();

() recv_internal(int balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);

    slice sender_address = cs~load_msg_addr();
    load_data();
    if (flags & 1) { ;; bounced messages
      ;; TODO
    }

    (int op, int query_id) = in_msg_body~load_body_header();

    if (op == halter::halt) {
        return process_halt_request(sender_address);
    } elseif (op == pool::withdraw) {
        assert_sender!(sender_address, jetton_minter);
        int jetton_amount = in_msg_body~load_coins();
        slice from_address = in_msg_body~load_msg_addr();
        ;; response will be ignored
        slice response_address = in_msg_body~load_msg_addr();
        int request_immediate_withdrawal = ~ in_msg_body~load_int(1);
        int fill_or_kill = in_msg_body~load_int(1);
        ;; after that point we should not revert because jettons should not be lost
        try {
            assert_not_halted!(); ;; otherwise mint back
            update_round();
            throw_unless(error::not_enough_TON_to_process, msg_value > WITHDRAWAL_FEE);
            int approximate_amount = muldiv(jetton_amount, total_balance, supply);
            int available_funds = balance - msg_value - MIN_TONS_FOR_STORAGE;

            if(optimistic_deposit_withdrawals &
                    request_immediate_withdrawal &
                    (state == state::NORMAL) &
                    (balance - msg_value - MIN_TONS_FOR_STORAGE > approximate_amount)) {
                total_balance -= approximate_amount;
                supply -= jetton_amount;
                raw_reserve(balance - msg_value - approximate_amount - sent_during_rotation, 0);
                var msg = begin_cell()
                        .store_msg_flags(msgflag::NON_BOUNCEABLE)
                        .store_slice(from_address)
                        .store_coins(0)
                        .store_msgbody_prefix_slice()
                        .store_body_header(pool::withdrawal, query_id);
                send_raw_message(msg.end_cell(), sendmode::CARRY_ALL_BALANCE);
            } else {
                throw_if(105, fill_or_kill);
                raw_reserve(balance - msg_value - sent_during_rotation, 0);
                request_to_mint_withdrawal(from_address, jetton_amount, query_id);
                requested_for_withdrawal += jetton_amount;
            }
        } catch (exc_arg, exc_num) {
            request_to_mint_pool_jettons(sender_address, jetton_amount, query_id, begin_cell(), true);
        }
        
    {- ========== Governance operations ========== -}
    } elseif (op == sudo::send_message) {
                process_sudo_request(sender_address, in_msg_body);
    } elseif (op == sudo::upgrade) {
        process_sudo_upgrade_request(sender_address, in_msg_body);
    } elseif (op == governor::set_sudoer) {
                process_set_sudo_request(sender_address, in_msg_body);
    } elseif (op == governor::unhalt) {
                process_unhalt_request(sender_address);
    } elseif (op == governor::set_roles) {
                assert_sender!(sender_address, governor);
                if(in_msg_body~load_int(1)) {
                    governor = in_msg_body~load_msg_addr();
                }
                if(in_msg_body~load_int(1)) {
                    interest_manager = in_msg_body~load_msg_addr();
                }
                if(in_msg_body.slice_refs()) {
                    in_msg_body = in_msg_body~load_ref().begin_parse();
                }
                if(in_msg_body~load_int(1)) {
                    halter = in_msg_body~load_msg_addr();
                }
    } elseif(op == governor::set_deposit_settings) {
                assert_sender!(sender_address, governor);
                optimistic_deposit_withdrawals = in_msg_body~load_int(1);
                deposits_open?  = in_msg_body~load_int(1);
    } elseif (op == interest_manager::set_interest) {
                assert_state!(state::NORMAL);
                assert_sender!(sender_address, interest_manager);
                interest_rate = in_msg_body~load_uint(16);
    } else {
        assert_not_halted!();
        update_round();
        ;; it is ok, controller knew how to process loan_repayment/request_loan bounces
        {- ========== Pool operations ========== -}
        if (op == pool::request_loan) {

              assert_state!(state::NORMAL);
              throw_if(error::borrowing_request_in_closed_round, current_round_closed?);

              int min_loan = in_msg_body~load_coins();
              int max_loan = in_msg_body~load_coins();
              int max_interest = in_msg_body~load_uint(16);
              slice static_data = in_msg_body;
              in_msg_body = in_msg_body.preload_ref().begin_parse();   ;; TODO we can use static_data to optimize check
              int controller_id = in_msg_body~load_uint(32);
              slice validator = in_msg_body~load_msg_addr();

              assert_sender!(sender_address, _get_controller_address(controller_id, validator));
              throw_unless(error::interest_too_low, max_interest >= interest_rate);

              ;; maybe too harsh conditions
              int creditable_funds = balance
                                     - muldiv_extra(requested_for_withdrawal, total_balance, supply)
                                     - MIN_TONS_FOR_STORAGE;
              ;;TODO
              int available_funds = creditable_funds; ;;min( creditable_funds, muldiv(256 + disbalance_tolerance, total_balance, 512) );

              min_loan = max(min_loan, min_loan_per_validator);
              max_loan = min(max_loan, max_loan_per_validator);

              throw_unless(error::contradicting_borrowing_params, min_loan <= max_loan);

              int actual_loan = min(available_funds, max_loan);

              throw_unless(error::not_enough_funds_for_loan, actual_loan >=  min_loan);

              int interest = muldiv(actual_loan, interest_rate, 65535);
              builder msg = begin_cell()
                        .store_msg_flags(msgflag::BOUNCEABLE)
                        .store_slice(sender_address)
                        .store_coins(actual_loan)
                        .store_msgbody_prefix_slice()
                        .store_body_header(controller::credit, query_id)
                        .store_coins(actual_loan + interest);
              send_raw_message(msg.end_cell(), sendmode::REGULAR);

              log_loan(sender_address, actual_loan);
              int total_loan = current_round_borrowers~add_loan(sender_address, actual_loan, interest);
              throw_unless(error::total_credit_too_high, total_loan <= max_loan + interest);
              send_msg_builder(interest_manager, SERVICE_NOTIFICATION_AMOUNT,
                        begin_cell()
                                .store_body_header(interest_manager::request_notification, cur_lt())
                                .store_coins(min_loan)
                                .store_coins(max_loan)
                                .store_uint(max_interest, 16),
                        msgflag::NON_BOUNCEABLE, sendmode::PAY_FEES_SEPARETELY);

        } elseif (op == pool::loan_repayment) {
            ;; we expect loans from previous round only
            ;; note, close_loan finalize round if last loan is closed
            (int closed, int last_one) = prev_round_borrowers~close_loan(sender_address, msg_value);
            ifnot (closed) {
              ;; lets check other side
              (int closed, last_one) = current_round_borrowers~close_loan(sender_address, msg_value);
              ifnot(closed) {
                ;; TODO, send to governance ????
              }
            }
            if(last_one) {
                update_round();
            }
        } elseif (op == pool::touch) {
            ;; return save_data
        } elseif (op == pool::deploy_controller) {
            assert_state!(state::NORMAL);
            int controller_id = in_msg_body~load_uint(32);
            (slice controller_address, cell init_state ) = build_controller_address(controller_id, sender_address);
            builder msg = begin_cell()
                          .store_msg_flags(msgflag::BOUNCEABLE)
                          .store_slice(controller_address)
                          .store_coins(0)
                          .store_msgbody_prefix_stateinit_slice(init_state)
                          .store_body_header(controller::top_up, cur_lt());
            send_raw_message(msg.end_cell(), sendmode::CARRY_ALL_REMAINING_MESSAGE_VALUE);
        } elseif (op == pool::deposit) {
            assert_state!(state::NORMAL);
            throw_unless(error::deposits_are_closed, deposits_open?);
            int deposit_amount = msg_value - DEPOSIT_FEE;
            throw_unless(error::deposit_amount_too_low, deposit_amount > 0);
            raw_reserve(balance - msg_value + deposit_amount - sent_during_rotation, 0);
            if(optimistic_deposit_withdrawals) {
              ;; we convert TON to Jetton at projected (expected) price at the round end
              (int expected_balance, int expected_supply) = _get_projected_conversion_ratio();

              int amount = muldiv_extra(deposit_amount, expected_supply, expected_balance);
              request_to_mint_pool_jettons(sender_address, amount, query_id, begin_cell(), true);
              total_balance += deposit_amount;
            } else {
              request_to_mint_deposit(sender_address, deposit_amount, query_id);
              requested_for_deposit += deposit_amount;
            }
        } else {
            throw(error::unknown_op);
        }
    }

    save_data();
}

(slice, cell) build_controller_address(int controller_id, slice validator) {
    cell static_data = begin_cell()
                          .store_uint(controller_id, 32)
                          .store_slice(validator)
                          .store_slice(my_address())
                          .store_slice(governor)
                          .store_ref(
                             begin_cell()
                             .store_slice(approver)
                             .store_slice(halter)
                             .end_cell()
                          )
                        .end_cell();
    cell init_state = controller_init_state(static_data);
    slice controller_address = calc_address(CONTROLLER_WORKCHAIN, controller_init_state(static_data));
    return (controller_address, init_state);
}

([cell, int, int, int, int, int, int], (int)) ~add_loan([cell, int, int, int, int, int, int] borrowers_data, slice borrower, int loan_body, int interest) {
    var [borrowers_dict, round_id, active_borrowers, borrowed, expected, returned, profit] = borrowers_data;

    (int wc, int addr_hash) = parse_std_addr(borrower);
    throw_unless(error::controller_in_wrong_workchain, wc == CONTROLLER_WORKCHAIN);

    int already_borrowed = 0;
    int accounted_interest = 0;
    (slice prev_data, int found?) = borrowers_dict.udict_get?(ADDR_SIZE, addr_hash);
    if(found?) {
        already_borrowed = prev_data~load_coins();
        accounted_interest = prev_data~load_coins();
    } else {
      active_borrowers += 1;
    }
    already_borrowed += loan_body;
    accounted_interest += interest;
    borrowed += loan_body;
    expected +=  loan_body + interest;

    borrowers_dict~udict_set_builder(ADDR_SIZE, addr_hash, begin_cell().store_coins(already_borrowed).store_coins(accounted_interest));

    throw_unless(error::credit_book_too_deep, cell_depth(borrowers_dict) < MAX_LOAN_DICT_DEPTH);

    return ([borrowers_dict, round_id, active_borrowers, expected, borrowed, returned, profit], already_borrowed);
}

([cell, int, int, int, int, int, int], (int, int)) ~close_loan([cell, int, int, int, int, int, int] borrowers_data, slice borrower, int amount) {
    var [borrowers_dict, round_id, active_borrowers, borrowed, expected, returned, profit] = borrowers_data;

    (int wc, int addr_hash) = parse_std_addr(borrower);
    throw_unless(error::controller_in_wrong_workchain, wc == CONTROLLER_WORKCHAIN);

    (slice prev_data, int found?) = borrowers_dict~udict_delete_get?(ADDR_SIZE, addr_hash);
    ifnot (found?) {
      return (borrowers_data, (false, false));
    }

    int was_borrowed = prev_data~load_coins();

    profit += amount - was_borrowed;

    returned += amount;

    active_borrowers -= 1;

    log_repayment(borrower, was_borrowed, amount - was_borrowed);

    borrowers_data = [borrowers_dict, round_id, active_borrowers, borrowed, expected, returned, profit];
    int last_one = active_borrowers == 0;

    return (borrowers_data, (true, last_one));
}

([cell, int, int, int, int, int, int], ()) finalize_lending_round([cell, int, int, int, int, int, int] borrowers_data) impure {
    ;; Does all the necessary value checks, sends logs
    ;; and governor fees, nulifies variables.
    var [borrowers_dict, round_id, active_borrowers, borrowed, expected, returned, profit] = borrowers_data;
    throw_unless(error::finalizing_active_credit_round, borrowers_dict.null?());
    throw_unless(error::finalizing_active_credit_round, active_borrowers == 0); ;; TODO - halt here?

    profit -= FINALIZE_ROUND_FEE;

    ;; governance_fee / 65536 < 1 ratio, share to send to governance
    int fee = max(muldiv(governance_fee, profit, 65536), 0);
    profit -= fee;

    ;; if there is negative profit (loss), then it can take maximum all the balance
    profit = max(profit, - total_balance);
    total_balance += profit;

    ;;int effective_supply = supply + requested_for_withdrawal;

    if (fee > SERVICE_NOTIFICATION_AMOUNT) { ;; otherwise it is less than msg cost
      sent_during_rotation += fee;
      send_msg_builder(governor, fee,
               begin_cell().store_body_header(governor::operation_fee, cur_lt()),
               msgflag::NON_BOUNCEABLE, sendmode::REGULAR);
      
    }
    sent_during_rotation += SERVICE_NOTIFICATION_AMOUNT;
    send_msg_builder(interest_manager, SERVICE_NOTIFICATION_AMOUNT,
             begin_cell()
               .store_body_header(interest_manager::stats, cur_lt())
               .store_coins(borrowed)
               .store_coins(returned)
               .store_signed_coins(profit), ;; duplication at this point?
             msgflag::NON_BOUNCEABLE, sendmode::PAY_FEES_SEPARETELY);
    log_round_completion(round_id, borrowed, returned, profit);

    finalize_deposit_withdrawal_round(round_id);

    ;; do we need to nulify data here ???
    return ([null(), round_id, 0, 0, 0, 0, 0], ());
}

() log_loan(slice lender, int amount) impure {
    emit_log(1, begin_cell().store_slice(lender)
                            .store_coins(amount));
}

() log_repayment(slice lender, int amount, int profit) impure {
    emit_log(2, begin_cell().store_slice(lender)
                            .store_coins(amount)
                            .store_signed_coins(profit));
}

() log_round_completion (int round_id, int borrowed, int returned, int profit) impure {
    emit_log(3, begin_cell().store_uint(round_id, 32)
                            .store_coins(borrowed)
                            .store_coins(returned)
                            .store_signed_coins(profit));
}

() log_round_rotation (int round_id) impure {
    emit_log(4, begin_cell().store_uint(round_id, 32));
}

() update_round() impure {
    sent_during_rotation = 0;
    if(halted?) {
        return ();
    }
    (int utime_since, int utime_until, cell vset) = get_current_validator_set();
    int current_hash = cell_hash(vset);
    if (saved_validator_set_hash != current_hash) {

      var [borrowers_dict, round_id, active_borrowers, borrowed, expected, returned, profit] = prev_round_borrowers;

      if((~ borrowers_dict.null?()) | (active_borrowers > 0)) {
        current_round_closed? = true;
        return ();
      } 
      prev_round_borrowers~finalize_lending_round();

      saved_validator_set_hash = current_hash;
      int round_index = current_round_index() + 1;
      log_round_rotation(round_index);
      (prev_round_borrowers, current_round_borrowers) = (current_round_borrowers, [null(), round_index, 0, 0, 0, 0, 0]);
      current_round_closed? = false;
    } else {
        current_round_closed? = false;
    }
}

() finalize_deposit_withdrawal_round (int round_id) {
    initiate_distribution_of_tons(round_id);
    initiate_distribution_of_pool_jettons(round_id);
}

() send_mint_message(slice minter, int query_id, slice destination, int amount, builder payload, int notification_ton, int forward_ton, int total_ton, int mode) impure {
    builder mint_request = begin_cell()
                .store_body_header(minter::mint, query_id)
                .store_slice(destination)
                .store_coins(amount) ;; max 124 bit
                .store_coins(notification_ton)
                .store_coins(forward_ton) ;; TRANSFER_NOTIFICATION_AMOUNT + JETTON_WALLET_FEE
                .store_uint(1, 1)
                .store_ref(payload.end_cell());
    var msg = begin_cell()
            .store_msg_flags(msgflag::BOUNCEABLE)
            .store_slice(minter)
            .store_coins(total_ton) ;;TRANSFER_NOTIFICATION_AMOUNT + JETTON_WALLET_FEE + MINT_FEE)
            .store_msgbody_prefix_slice()
            .store_builder(mint_request);
    send_raw_message(msg.end_cell(), mode); ;; pay transfer fees separately, revert on errors
}

() request_to_mint_pool_jettons(slice destination, int amount, int query_id, builder payload, int for_user?) impure {
    if (for_user?) {
      send_mint_message(jetton_minter, query_id, destination, amount, payload,
              DEPOSIT_FEE - MAX_POOL_GAS_ON_USER_ACTION - POOL_JETTON_WALLET_FEE - POOL_JETTON_MINT_FEE - 16800000, ;;TODO
              DEPOSIT_FEE - MAX_POOL_GAS_ON_USER_ACTION - POOL_JETTON_WALLET_FEE,
              DEPOSIT_FEE - MAX_POOL_GAS_ON_USER_ACTION,
              sendmode::PAY_FEES_SEPARETELY);
      var msg = begin_cell()
                .store_msg_flags(msgflag::NON_BOUNCEABLE)
                .store_slice(destination)
                .store_coins(0)
                .store_msgbody_prefix_slice()
                .store_body_header(jetton::excesses, query_id);
      send_raw_message(msg.end_cell(), sendmode::CARRY_ALL_BALANCE);
    } else {
      send_mint_message(jetton_minter, query_id, destination, amount, payload,
              TRANSFER_NOTIFICATION_AMOUNT,
              TRANSFER_NOTIFICATION_AMOUNT + POOL_JETTON_WALLET_FEE,
              TRANSFER_NOTIFICATION_AMOUNT + POOL_JETTON_WALLET_FEE + POOL_JETTON_MINT_FEE,
              sendmode::REGULAR
      );
      sent_during_rotation += TRANSFER_NOTIFICATION_AMOUNT + POOL_JETTON_WALLET_FEE + POOL_JETTON_MINT_FEE;
    }
    supply += amount;
}

() request_to_mint_deposit(slice destination, int amount, int query_id) impure {
    if(deposit_payout.null?()) {
        ;; we need to deploy new minter
        cell state_init = calculate_payout_state_init(my_address(), current_round_index(), true);
        slice to_address = calc_address(JETTONS_WORKCHAIN, state_init);
        deposit_payout = to_address;
        slice deposit_minter_jetton_wallet = calc_address(JETTONS_WORKCHAIN,
          calculate_jetton_wallet_state_init(to_address, jetton_minter, pool_jetton_wallet_code)
        );
        builder msg = begin_cell()
                      .store_msg_flags(msgflag::BOUNCEABLE)
                      .store_slice(deposit_payout)
                      .store_coins(MINTER_DEPLOY_FEE)
                      .store_msgbody_prefix_stateinit_slice(state_init)
                      .store_body_header(payout::init, cur_lt())
                      .store_ref(
                         begin_cell()
                           .store_uint(0, 1) ;; distribution not started
                           .store_uint(1, 1) ;; jettons
                           .store_coins(0)
                           .store_slice(deposit_minter_jetton_wallet)
                         .end_cell()
                      );
        send_raw_message(msg.end_cell(), sendmode::REGULAR);
    }
    send_mint_message(deposit_payout, query_id, destination, amount, begin_cell(),
                       DEPOSIT_FEE - MAX_POOL_GAS_ON_USER_ACTION - PAYOUT_PROCESS_FEE - PAYOUT_ITEM_MINT_FEE,
                       DEPOSIT_FEE - MAX_POOL_GAS_ON_USER_ACTION - PAYOUT_PROCESS_FEE,
                       DEPOSIT_FEE - MAX_POOL_GAS_ON_USER_ACTION,
                       sendmode::PAY_FEES_SEPARETELY
                     );
    var msg = begin_cell()
            .store_msg_flags(msgflag::NON_BOUNCEABLE)
            .store_slice(destination)
            .store_coins(0)
            .store_msgbody_prefix_slice()
            .store_body_header(jetton::excesses, query_id);
    send_raw_message(msg.end_cell(), sendmode::CARRY_ALL_BALANCE | sendmode::IGNORE_ERRORS);
}

() request_to_mint_withdrawal(slice destination, int amount, int query_id) impure {
    if(withdrawal_payout.null?()) {
        ;; we need to deploy new minter
        cell state_init = calculate_payout_state_init(my_address(), current_round_index(), false);
        slice to_address = calc_address(JETTONS_WORKCHAIN, state_init);
        withdrawal_payout = to_address;
        builder msg = begin_cell()
                      .store_msg_flags(msgflag::BOUNCEABLE)
                      .store_slice(withdrawal_payout)
                      .store_coins(MINTER_DEPLOY_FEE)
                      .store_msgbody_prefix_stateinit_slice(state_init)
                      .store_body_header(payout::init, cur_lt())
                      .store_ref(
                         begin_cell()
                           .store_uint(0, 1) ;; distribution not started
                           .store_uint(0, 1) ;; TONs
                           .store_coins(0)
                         .end_cell()
                      );
        send_raw_message(msg.end_cell(), sendmode::REGULAR);
    }
    send_mint_message(withdrawal_payout, query_id, destination, amount, begin_cell(),
            DEPOSIT_FEE - MAX_POOL_GAS_ON_USER_ACTION - PAYOUT_PROCESS_FEE - PAYOUT_ITEM_MINT_FEE,
            DEPOSIT_FEE - MAX_POOL_GAS_ON_USER_ACTION - PAYOUT_PROCESS_FEE,
            DEPOSIT_FEE - MAX_POOL_GAS_ON_USER_ACTION,
            sendmode::PAY_FEES_SEPARETELY
    );
    var msg = begin_cell()
            .store_msg_flags(msgflag::NON_BOUNCEABLE)
            .store_slice(destination)
            .store_coins(0)
            .store_msgbody_prefix_slice()
            .store_body_header(jetton::excesses, query_id);
    send_raw_message(msg.end_cell(), sendmode::CARRY_ALL_BALANCE);
}

() initiate_distribution_of_tons(round_id) impure {
    ;; Sends tons for distribution, in proportion to
    ;; the number requested before the start of the round.
    ifnot(requested_for_withdrawal) {
        return ();
    }
    int ton_withdrawal = muldiv(requested_for_withdrawal, total_balance, supply);
    slice prev_withdrawal_payout = withdrawal_payout;
    if(pair_first(get_balance()) < ton_withdrawal + MIN_TONS_FOR_STORAGE) {
      ;; not enough money to withdraw
      halted? = true;
      state = state::REPAYMENT_ONLY;
      return ();
    } else {
        supply -= requested_for_withdrawal;
        requested_for_withdrawal = 0;
        withdrawal_payout = null();
    }

    total_balance -= ton_withdrawal;
    sent_during_rotation += ton_withdrawal;
    var msg = begin_cell()
            .store_msg_flags(msgflag::BOUNCEABLE)
            .store_slice(prev_withdrawal_payout)
            .store_coins(ton_withdrawal)
            .store_msgbody_prefix_slice()
            .store_body_header(payouts::start_distribution, cur_lt());
    send_raw_message(msg.end_cell(), sendmode::REGULAR);
}

() initiate_distribution_of_pool_jettons(round_id) impure {
    ;; Distributes pool tokens among those who received
    ;; deposit tokens before the start of the round.
    ifnot(requested_for_deposit) {
        return ();
    }
    int jetton_mint = muldiv_extra(requested_for_deposit, supply, total_balance);
    sent_during_rotation += TRANSFER_NOTIFICATION_AMOUNT + POOL_JETTON_WALLET_FEE + POOL_JETTON_MINT_FEE;
    request_to_mint_pool_jettons(deposit_payout,
                                 jetton_mint,
                                 cur_lt(),
                                 begin_cell()
                                   .store_body_header(payouts::start_distribution, cur_lt()),
                                 false
                                );
    total_balance += requested_for_deposit;
    deposit_payout = null();
    requested_for_deposit = 0;
}

int current_round_index() {
    ;;TODO optimize
    var [borrowers_dict, round_id, active_borrowers, borrowed, expected, returned, profit] = current_round_borrowers;
    return round_id;
}

int get_round_index() method_id {
    load_data();
    return current_round_index();
}

slice get_current_round_deposit_payout() method_id {
    load_data();
    return deposit_payout;
}

slice get_current_round_withdrawal_payout() method_id {
    load_data();
    return withdrawal_payout;
}

(int, int, int, int, slice, int) get_finance_data() method_id {
    load_data();
    return (total_balance, supply, requested_for_deposit, requested_for_withdrawal, jetton_minter, interest_rate);
}

(slice) _get_controller_address(int controller_id, slice validator) inline {
    var (controller_address, _) = build_controller_address(controller_id, validator);
    return controller_address;
}

(int, int) _get_projected_conversion_ratio () inline {
    var [borrowers_dict, round_id, active_borrowers, borrowed, expected, returned, profit] = prev_round_borrowers;
    return (expected - borrowed + total_balance, supply);
}


(int, int) get_projected_conversion_ratio () method_id {
  load_data();
  return _get_projected_conversion_ratio();
}

(slice) get_controller_address(int controller_id, slice validator) method_id {
    load_data();
    return _get_controller_address(controller_id, validator);
}

(int, int) get_controller_address_legacy(int controller_id, int wc, int addr_hash) method_id {
    load_data();
    var (controller_address, _) = build_controller_address( controller_id,
      begin_cell()
           .store_uint(4, 3).store_int(wc, 8).store_uint(addr_hash, ADDR_SIZE)
      .end_cell().begin_parse());
    return parse_std_addr(controller_address);
}

(int, int, int, int, slice) get_pool_credit_params() method_id {
    load_data();
    return (min_loan_per_validator, max_loan_per_validator,
            interest_rate, governance_fee,
            interest_manager);
}

cell get_borrowers_dict(int prev?) method_id {
    load_data();
    var round_borrowers = prev? ? prev_round_borrowers
                            : current_round_borrowers;
    var [borrowers_dict, round_id, active_borrowers, borrowed, expected, returned, profit] = round_borrowers;
    return borrowers_dict;
}

(int, int) get_loan(int controller_id, slice validator_address, int prev?) method_id {
    load_data();
    var round_borrowers = prev? ? prev_round_borrowers
                            : current_round_borrowers;
    var [borrowers_dict, round_id, active_borrowers, borrowed, expected, returned, profit] = round_borrowers;
    (slice controller_address, _) = build_controller_address(controller_id, validator_address);
    (int wc, int addr_hash) = parse_std_addr(controller_address);
    (slice loan_data, int found?) = borrowers_dict.udict_get?(ADDR_SIZE, addr_hash);
    ifnot (found?) {
        return (0, 0);
    }
    int borrowed_amount = loan_data~load_coins();
    int accounted_interest = loan_data~load_coins();
    return (borrowed_amount, accounted_interest);
}

(int, int) get_min_max_loan_per_validator() method_id {
    load_data();
    return (min_loan_per_validator, max_loan_per_validator);
}
